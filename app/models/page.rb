class Page < ActiveRecord::Base
  has_many :attachments
  accepts_nested_attributes_for :attachments, :allow_destroy => true

  cattr_reader :per_page
  @@per_page = 20

  validates_presence_of :title
  validates_uniqueness_of :title, :case_sensitive => false
  acts_as_ferret :fields  => [:title, :body]
  acts_as_taggable
  
  named_scope :latest, :limit => 5, :order => "updated_at desc"
  named_scope :begins_with, lambda { |str| 
    { 
      :conditions => ['lower(title) LIKE ?', %(#{str.downcase}%)],
      :order => 'title asc'
    } 
  }
  named_scope :all_sorted_by_title, :order => 'title asc'
  named_scope :find_by_title_insensitive, lambda { |str|
    {
      :conditions => ['lower(title) = ?', %(#{str.downcase})]  
    }
  }

  def self.paged_find_tagged_with(tags, args = {})
    if tags.blank?
      paginate args
    else
      options = find_options_for_find_tagged_with(tags, :match_all => true)
      options.merge!(args)
      # The default count query generated by paginate includes COUNT(DISTINCT Posts.*) which errors, at least on mysql

      # Below we override the default select statement used to perform the count so that it becomes COUNT(DISTINCT Posts.id)

      paginate(options.merge(:count => { :select => options[:select].gsub('*', 'id') }))
    end
  end

  def attached_files=(files)
    self.attachments << process_uploaded_files(files)
  end

private 
  def process_uploaded_files(files)
    attachments = []
    files.each do |f|
      local_file_name = File.basename(f.original_filename)
      local_path = File.join('public', 'files', local_file_name)
      attachments << Attachment.new(:file_name => local_file_name)
      File.open(local_path, "wb") { |u| u.write(f.read) }
    end
    attachments
  end
end
